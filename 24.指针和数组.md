**数组：**

- **存储在一块连续的内存空间，存储在栈上**，除非用malloc函数操作堆指针

- **数组名就是这块连续内存空间的首地址**

```python
double score[5] = {12,23,34,45,56};
double * ptr_score;
ptr_score = &score[0];
//ptr_score = score;  数组名就是数组首元素的地址
```

### 指针运算

**指针的算术运算**

- 指针的递增和递减(++, --)。**注意！！！一个类型为T的指针的移动是以sizeof(T)为移动单位**例如double \* 的指针++， 实质地址是增加了8

  ```python
  int i;
  double score[5] = {98, 35, 63, 45, 65};
  double * ptr_score;
  ptr_score = score;
  for(i = 0; i < 5; i++){
      printf("%.2lf\n", score[i]);
      //printf(("%.2lf\n", *(ptr_score + i));   //推荐方式，注意是以sizeof(T)为移动单位
      //printf("%.2lf\n", *ptr_score++);  //不推荐， 打印过程中指针移动了
  }
  ```

**不能通过数组指针来得到数组的大小**

```c
int main( )
{
    int p[10] = {1,2,3,4,5};
    int *p1 = p;
    printf("p size: %d\n", sizeof(p));
    printf("p1 size: %d\n", sizeof(p1));
    return 0;
}

p size: 40
p1 size: 4
```





### 数组与指针小结

数组名就是这块连续内存单元的首地址

- int num\[50]; //num是数组名，也是数组的首地址

- num的值与&num\[0]的值是相同的

- 数组第i+1个元素可以表示为：

  - 第i+1个元素的地址：&num\[i+1]或**num+i+1**

  - 第i+1个元素的值：num\[i+1]或*(num + i+ 1)

- 为指向数组的指针赋值：

  - **int * ptr_num = num;**

  - int * ptr_num = &num\[0];

- 指针变量可以指向数组元素：

  - int * ptr_num = &num\[4];或int * ptr_num = num + 4

### 二维数组和指针

- `int a[2][2] = {2,3,4,5}`

- 二维数组的首地址：&a\[0]\[0]

- 使用指针访问二维数组中的元素：

  - *(a\[1]+2)  //a\[1]相当于一个一维数组的数组名，代表一维数组的首地址

  - \*(*(a+1)+2)    //看作a有两个元素，a\[0]和a\[1]，a+1为a\[1]的地址，\*(a+1)就是a\[1]首元素的地址，\*(a+1) + 2就是a\[1]第三个元素的地址。

**注意：**

```python
int a[2][3] = {2,3,4,5,6,7};
//int * ptr = a;  错误的因为a的每个元素是一个数组，而不是一个单独的int类型
int (* ptr)[3] = a
```

### 数组指针和指针数组

**数组指针（也称行指针）**  
定义 int (*p)\[n];  
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

如要将二维数组赋给一指针，应这样赋值：  
int a\[3]\[4];  
int (*p)\[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。  
 p=a;        //将该二维数组的首地址赋给p，也就是a\[0]或&a\[0]\[0]  
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a\[0][]指向了行a\[1][]

所以数组指针也称指向一维数组的指针，亦称行指针。

**在这里\*(\*(p+1)+2)指的是p\[1]\[2]的值**

`printf("pointer of the array: address is %p\nfirst element of the array: address is %p, value is %d\n", a, *a, *(*a));`

**指针数组**  
定义 int *p\[n];  
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。  
如要将二维数组赋给一指针数组:  
int *p\[3];  
int a\[3]\[4];  
p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针  
for(i=0;i<3;i++)  
p\[i]=a\[i]  
这里int *p\[3] 表示一个一维数组内存放着三个指针变量，分别是p\[0]、p\[1]、p\[2] 分别对应a\[0],a\[1],a\[2]
所以要分别赋值。

这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。  
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。  
比如要表示数组中i行j列一个元素：  
`*(p\[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]`

优先级：()>[]>*

### 元素地址和内存块地址

### 1.一维数组

**数组名**

　　先看下面表达式：

```python
int a[10]; 
int b[10]; 
int *c;
c=&b[0]
c=a;
```

　　对于第一行，a\[4]表示一个整形，**那么a的类型又是什么呢？答案是它表示数组元素的第一个地址**，**类型为取决于数组元素的类型**，在此数组元素的类型为int，所以数组名a的类型为”**指向int的常量指针**“（注意是指针常量而不是指针变量）。**只有在两种场合下，数组名并不用指针常量来表示——当数组名作为sizeof操作符或单目操作符&的操作数时。sizeof返回整个数组长度，取数组名地址所产生的是指向数组的指针。**

　　表达式&b\[0]是一个指向数组第一个元素的指针，也是数组名本身的值，所以等价于：

`c=b;`

　　但是以下表达式是错误的：

`a=c;`
`a=b;`

　　第一行，a为指针常量，而c是指针变量，不能把一个变量赋值给常量。第二行是非法的，不能用赋值符把一个数组的所有元素赋值到另一个数组，必须使用一个循环，每次赋值一个元素。

**一维数组**

```python
int a[3] = {1.2.3};
// a->a[0]的地址，也就是数组首元素的地址，printf("%p", a+1);//数值大4，也就是int类型的字节长度
// &a->数组对应内存块的首地址，数值上和数组首元素的地址一样，printf("%p", &a+1); //数值大12，就是整个数组的字节长度一共三个int类型占12字节
```

**二维数组**

```python
int a[2][3] = {1,2,3,4,5,6};
//a[0]->a[0][0]的地址，对应的是数组首元素的地址，printf("%p", a[0]+1);//数值大12，也就是int类型的字节长度
//a->a[0]的地址，对应的是a[0]内存块的首地址，printf("%p", a+1);//数值大12，也就是数组a[0]的字节长度
//&a->a对应内存块的首地址，printf("%p", &a+1);//数值大24，也就是整个数组的字节长度
```
