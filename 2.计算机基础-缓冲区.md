作者：守住这块热土
 链接：https://www.jianshu.com/p/56758d388ed1
 來源：简书
 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

 **缓冲区---用来协调高速低速设备之间的通信，cache是一种缓冲区**



- 输入或者输出之后要清空缓冲区

  - fflush(stdin)

  - fflush(stdout);



#### Part1 缓冲区

##### 一、什么是缓冲区

**缓冲区又称为缓存**，它是**内存空间**的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来*缓冲输入或输出的数据*，这部分预留的空间就叫做缓冲区。  
缓冲区根据其对应的是输入设备还是输出设备，分为**输入缓冲区**和**输出缓冲区**。

##### 二、为什么要引入缓冲区

我们为什么要引入缓冲区呢？

![Image\增加缓冲区的优点](Image\增加缓冲区的优点.webp)

比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，**这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度**。  

又比如，我们使用打印机打印文档，**由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区**，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。  

现在您基本明白了吧，缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。**它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。**

##### 三、缓冲区的类型

缓冲区分为三种类型：全缓冲、行缓冲和不带缓冲。

###### 1、全缓冲

在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是**对磁盘文件的读写**。

###### 2、行缓冲

在这种情况下，**当在输入和输出中遇到换行符时，执行真正的I/O操作。**这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。**典型代表是键盘输入数据。**

###### 3、不带缓冲

也就是不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来。

##### 四、缓冲区的刷新

下列情况会引发缓冲区的刷新:

**注意：flush, endl语句是刷新输出缓冲区**

```
缓冲区满时；  
执行flush语句；  
执行endl语句；  
关闭文件。
```

可见，缓冲区满或关闭文件时都会刷新缓冲区，进行真正的I/O操作。另外，在C++中，我们可以**使用flush函数来刷新缓冲区（执行I/O操作并清空缓冲区）**，如：  

`cout<<flush;` //将显存的内容立即输出到显示器上进行显示。  

**endl控制符的作用是将光标移动到输出设备中下一行开头处，并且清空缓冲区。**

`cout<<endl; `

相当于 cout<<”\n” <<flush;

##### 五、 刷新输出缓冲区

endl 操纵符，用于输出一个换行符并刷新缓冲区。  
flush操纵符，用于刷新流，但不在输出中添加任何字符。  
ends操作符，这个操纵符在缓冲区中插入空字符 null，然后后刷新它。

**五、实例演示**

**1、文件操作演示全缓冲**

创建一个控制台工程，输入如下代码：

```
#include <fstream>  
using namespace std;  
int main()  
{  
//创建文件test.txt并打开  
ofstream outfile("test.txt");  
//向test.txt文件中写入4096个字符’a’  
for(int n=0;n<4096;n++)  
{  
outfile<<'a';  
}  
//暂停，按任意键继续  
system("PAUSE");  
//继续向test.txt文件中写入字符’b’，也就是说，第4097个字符是’b’  
outfile<<'b';  
//暂停，按任意键继续  
system("PAUSE");  
return 0;  
}
```

上面这段代码很容易理解，已经在代码内部作了注释。

编写这段小代码的目的是验证WindowsXP下全缓冲的大小是4096个字节，并验证缓冲区满后会刷新缓冲区，执行真正的I/O操作。

编译并执行，运行结果如下：

[![运行结果](https://s2.51cto.com/wyfs02/M01/A1/A2/wKioL1mfrfXj7YL8AAAjKjm0BiQ87.jpeg-wh_651x-s_3217228992.jpeg)](https://s2.51cto.com/wyfs02/M01/A1/A2/wKioL1mfrfXj7YL8AAAjKjm0BiQ87.jpeg-wh_651x-s_3217228992.jpeg)

此时打开工程所在文件夹下的test.txt文件，您会发现该文件是空的，这说明4096个字符“a”还在缓冲区，并没有真正执行I/O操作。敲一下回车键，窗口变为如下：

[![](https://s3.51cto.com/wyfs02/M02/02/F2/wKiom1mfrgHh6_PyAAAnO_cVwrY99.jpeg-s_3303986517.jpeg)](https://s3.51cto.com/wyfs02/M02/02/F2/wKiom1mfrgHh6_PyAAAnO_cVwrY99.jpeg-s_3303986517.jpeg)

此时再打开test.txt文件，您就会发下该文件中已经有了4096个字符“a”。这说明全缓冲区的大小是4K（4096），缓冲区满后执行了I/O操作，而字符“b”还在缓冲区。

再次敲一下回车键，窗口变为如下：

[![](https://s3.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfWyfrx3AAAsWmKZmPU57.jpeg-s_2934490463.jpeg)](https://s3.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfWyfrx3AAAsWmKZmPU57.jpeg-s_2934490463.jpeg)

此时再打开test.txt文件，您就会发现字符“b”也在其中了。这一步验证了文件关闭时刷新了缓冲区。

**2、键盘操作演示行缓冲**

先介绍getchar()函数。

函数原型：int getchar(void);

说明：当程序调用getchar()函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar()函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的getchar()函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。

不知道您明白了没有，再通俗一点讲，当程序调用getchar()函数时，程序就等着用户按键，并等用户按下回车键返回。期间按下的字符存放在缓冲区，第一个字符作为函数返回值。继续调用getchar()函数，将不再等用户按键，而是返回您刚才输入的第2个字符；继续调用，返回第3个字符，直到缓冲区中的字符读完后，才等待用户按键。

如果您还没有明白，只能怨我表达能力有限，您可以结合以下实例体会。

创建一个控制台工程，输入如下代码：

```
#include <iostream>  
using namespace std;  
int main()  
{  
char c;  
//第一次调用getchar()函数  
//程序执行时，您可以输入一串字符并按下回车键，按下回车键后该函数才返回  
c=getchar();  
//显示getchar()函数的返回值  
cout<<c<<endl;  
//暂停  
system("PAUSE");  
//循环多次调用getchar()函数  
//将每次调用getchar()函数的返回值显示出来  
//直到遇到回车符才结束  
while((c=getchar())!='\n')  
{  
printf("%c",c);  
}  
//暂停  
system("PAUSE");  
return 0;  
}
```

这段小代码也很简单，同样在代码内部都有注释。

getchar()函数的执行就是采用了行缓冲。第一次调用getchar()函数，会让程序使用者（用户）输入一行字符并直至按下回车键 函数才返回。此时用户输入的字符和回车符都存放在行缓冲区。再次调用getchar()函数，会逐步输出行缓冲区的内容。

好了，本人表达能力有限，还是编译运行程序，通过运行结果自己领会吧。

编译运行程序，会提示您输入字符，您可以交替按下一些字符，如下：

[![](https://s1.51cto.com/wyfs02/M02/A1/A2/wKioL1mfrfXBc7mhAABDTpxsXe047.jpeg-s_820676664.jpeg)](https://s1.51cto.com/wyfs02/M02/A1/A2/wKioL1mfrfXBc7mhAABDTpxsXe047.jpeg-s_820676664.jpeg)

您一直按下去，您就会发现当您按到第4094个字符时，不允许您继续输入字符。这说明行缓冲区的大小也是4K。

此时您按下回车键，返回第一个字符’a’，如下图：

[![](https://s5.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfWRy0P_AAEgsVkht3Y81.jpeg-s_2596444817.jpeg)](https://s5.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfWRy0P_AAEgsVkht3Y81.jpeg-s_2596444817.jpeg)

继续敲一下回车键，将缓冲区的其它的字符全部输出，如下图：

[![](https://s1.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfXAxT_uAAEyHEfjSAM10.jpeg-s_723165065.jpeg)](https://s1.51cto.com/wyfs02/M00/A1/A2/wKioL1mfrfXAxT_uAAEyHEfjSAM10.jpeg-s_723165065.jpeg)

**3、标准错误输出不带缓冲**

如错误输出时使用：

1. cerr<<”错误，请检查输入的参数!”; 

这条语句等效于：

1. fprintf(stderr, ”错误，请检查输入的参数!”);
