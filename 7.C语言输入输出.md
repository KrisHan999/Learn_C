1. printf() & scanf()

- **为什么定义字符数组而用scanf却可以输入超过其长度的字符串呢？**

  scanf函数是可以限制输入长度的`scanf("%5s", a)`，**但`scanf("%s",a)`这种写法没有使用它的限制功能**，所以是不检查字符串长度；[C/C++](https://www.baidu.com/s?wd=C%2FC%2B%2B&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)也是不检查数组越界的。防止数组越界的任务完全由程序员事先安排完成；**越界了就会产生不良或危险后果，正规软件中是绝对不能允许的。**正因为“不检查”，当越界操作数组时，在越界部分没有受到“其他干扰”的情况下自然也能“正常”表现。

  定义了数组，**编译器为这个数组在栈里开辟了3个字节的内存空间，但是这3个空间之后的一些空间是没有被占用的，所以你就成功得输入了6个数到这个数组中**……**但是如果之后的空间被占用了，就会导致严重的问题，会提示该内存不可写**，比如你可以试着输入100个数。。这种错误在写程序时犯下是比较严重的，所以程序员一般在输入时会检测筛选你输入的内容，或者是开辟一个够大的数组

2. getchar()与putchar()

3. gets()和puts()

4. 清空输入输出缓冲区

   ```c
   //清空输入缓冲区
   fflush(stdin);
   //scanf("%*s");   //*表示输入项在读入后不赋值给相应项，相当于清空输入缓冲区，作用也是清空缓冲区
   
   //清空输出缓冲区
   fflush(stdout);
   ```

参考资料：[https://www.cnblogs.com/JCSU/articles/1306308.html](https://www.cnblogs.com/JCSU/articles/1306308.html)

**getche()与getch()**

**getc()和putc()**

1. printf() & scanf()

   - 字符串：

     ```python
     char ch[6];
     scanf(%s, ch);   //ch这里已经表示地址，所以不需要&，%s需要的是char * 参数，而不是char *[6]参数
     printf(%s, ch);
     ```

2. getchar() & putchar()

3. gets() & puts()

## 1.printf() & scanf()

> **标准输入输出**：属于行缓冲，等待回车键之后载入，直到缓冲区为空才会重新等待。

- printf(): 将指定的文字/字符串输出到便准输出设备（屏幕）

  - 注意**宽度输出**和**精度输出**控制
  - **printf遇到`\0`就会自动停止输出**

- scanf(): 从便准输入设备（键盘）读取设备，并将值存放在变量中。

  - 也存在**宽度输出和精度输出控制**
  - **char ch\[10]**: scanf时如果只输入7个字符，第八个字符就是\0；如果输入大于或等于10个，最后一位就不是\0

### 1.1.格式说明符的个数与输入数据个数不相等的情况

当我们从键盘输入数据时，数据之间必须用分隔符分开(空格、Tab键、回车)。并且要求scanf函数中格式说明符的个数与数据列表中数据的个数相等。如： 

`scanf("%d%d", &a, &b); //&a, &b需要将缓冲区中的数填入到a,b地址的位置 `  

**要注意不能 `scanf("%d, %d", &a, &b);` 这样的话会把`,`对应的45赋值给b**

`scanf("%d%d%d", &a, &b, &c);  `

`scanf``(``"%d %d"``,&a,&b);`

**函数返回值为int型。如果a和b都被成功读入**，**那么scanf的返回值就是2；**

**如果只有a被成功读入，返回值为1；**

**如果a和b都未被成功读入，返回值为0；**

如果遇到错误或遇到end of file，返回值为EOF。end of file为Ctrl+z 或者Ctrl+d。

如果出现不相等的情况，我们应该怎么分析呢？

其实，**当我们初次输入数据时，只要没有按回车键，所输入的数据都还存放在缓冲区，并没有存入变量中**。**按【Enter】键后，scanf()函数才会从缓冲区中取走数据**。**缓冲区是一个先进先出的队列**，即取走数据的时候，遵循先输入的数据先取走的原则。scanf函数的格式说明符有几个就要取几次数据，只要碰到格式说明符就必须把数据取走，至于是不是要把取走的数据存放起来，就得看数据列表中的数据个数。**没取完的数据继续留在缓冲区中。**

以下是缓冲区示意图，它像一根管道，有一个入口和一个出口，数据只能从入口中存入，只能从出口中取出。

![](https://images.cnblogs.com/cnblogs_com/jcsu/c/c_scanf.GIF)

以下是针对该图的C程序，数据输入为：10<空格>20<空格>30<空格>40<回车>

```
/*
 * 输入数据格式：10<空格>20<空格>30<空格>40<回车>
 * 输出：a=10 b=20
 c=30
 */
#include <stdio.h>
int main()
{
 int a, b, c;
 scanf("%d%d", &a, &b); /* scanf中有2个格式说明符，表明要取两次数据，取走10和20
 缓冲区中还剩下30和40
 *
 printf("a=%d b=%d \n", a, b);
 scanf("%d", &c); /* scanf中只有1个格式说明符，表明要取1次数据，取走30
 缓冲区中还剩下40，因此，读者还可以取一次。。。。。
 */
 printf("c=%d \n", c);
 return 0;
}
```

### 1.2.宽度输出的情况

1. 在%和格式字符之间加入一个**整数**来控制输出数据所占宽度

   ```
   printf("%d\n", 365);
   printf("%2d\n", 365);
   printf("%5d\n", 365);
   printf("%f\n", 3.14);
   printf("%6f\n", 3.14);
   printf("%12f\n", 3.14);
   ```

   输出效果：

   ![](https://images.cnblogs.com/cnblogs_com/jcsu/c/printfwidthcontrol1.GIF)

2. 在%和格式字符f之间加入一个“**整数1.** **整数2**”来控制输出数据的格式

   整数1：整个输出数据占的总宽度(包括小数点)

   整数2：输出实数的小数部分的个数

   记住：**先用整数2处理小数部分，再用整数1处理整个数据，包括已处理好的小数部分**

   ```
   printf("%3.3f\n", 3.1415);
   printf("%3.5f\n", 3.1415);
   printf("%9.5f\n", 3.1415);
   printf("%9.0f\n", 3.1415);
   ```

   输出效果：

   **![](https://images.cnblogs.com/cnblogs_com/jcsu/c/printfwidthcontrol2.GIF)**

   **默认是右对齐，在%后紧跟一个"-"，变为左对齐。**

### 1.3.宽度输入的情况

宽度输入指的是在%和格式说明符d之间加入一个整数。如：scanf("%2d", &x);

**规则：**  
(1)注意：%d与%1d是不同的  
**(2) 当宽度小于数据的实际宽度时，截取指定宽度的部分作为一个数进入缓冲区，再将剩余部分作为另一个数放入缓冲区。**

基于以下程序进行测试，测试结果如下：

```
#include <stdio.h>

main()

{

    int a;

    float b,c;

    scanf("%3d%f%f",&a,&b,&c);

    printf("%d %f %f \n", a, b, c);

}
```

test case #1：  
输入：1<空格>2<空格>3<回车>  
输出：1 2.000000 3.000000  

test case #2：  
输入：123<空格>4<空格>5.1234567<回车>  
输出：123 4.000000 5.123456  

test case #3：  
输入：1234<空格>5<空格>6<回车>  
输出：123 4.000000 5.000000  

test case #4：  
输入：1.23<空格>4<空格>5<回车>  
输出：1 0.230000 4.000000  

test case #5：  
输入：123.45<空格>6<空格>7<回车>  
输出：123 0.450000 6.000000  

test case #6：  
输入：1234.5<空格>6<空格>7<回车>  
输出：123 4.500000 6.000000

## **1.2 getchar()与putchar()**： 对单个字符操作

**getchar()**:将用户输入的字符输出到标准输出设备(屏幕)。**按【Enter】键后**，**getchar()函数才会读入第一个字符**，并返回该字符常量。

**注：**由于缓冲区的读取特性，当用户由键盘键入字符时，计算机并不会马上处理，而会暂存到系统的缓冲区(Buffter)内。**到按【Enter】键后，getchar()函数才会读入缓冲区的第一个字符。而其它字符继续保留在缓冲区，等待下一个读取字符/字符串的函数来读入。**

**putchar()**:用来输出指定的**单一字符**。

**例1.**运行以下程序，输入：Hello!<回车>

```
#include <stdio.h>

int main()
{
    char c, s[20];
    printf("Enter a string: ");
    c = getchar();
    printf("Read the remaining from the buffer\n");
    scanf("%s", s);

    putchar(c);
    putchar('\n');
    printf("%s \n", s);
}
```

**例2.**输入一个汉字，并将它显示在屏幕上。

先输入：B超<回车>，观察输出。再运行程序，输入：超<回车>，比较输出结果：

```
#include <stdio.h>

int main()
{
    char c1, c2;
    printf("Enter an Chinese character: ");

    c1 = getchar();
    c2 = getchar();

    printf("The Chinese character entered is: ");

    putchar(c1);
    putchar(c2);

    putchar('\n');
}
```

**一个汉字需要两个字节（字符）才能表示。只输入“超”字时，通过两个getchar()函数将缓冲区中的“超”字全部读出，并用两次putchar()显示了一个完整的汉字。**

## 1.4.gets()和puts()

**gets():** **scanf输入字符串可以配合%s格式，但缺点是当遇到字符串中有空白或tab字符时，会自动视为串输入结束， 并且将结束符\0录入字符串中**。因此不适合输入包含空白/tab字符的字符串。这时gets()函数就可解决该问题。

**gets()函数会将用户整段字符串响应到标准输出设备(屏幕)上，当用户按下【Enter】键时，会读取缓冲区的所有字符并存放到指定字符数组中。**

比较适合应用在多字符，中文字或长字符串的读取。

**puts():用来输出字符串，输出完成后光标自动移到下一行。当输出数据时，会以'\0'字符作为该字符串的结束。**

```c
#include <stdio.h>
int main()
{
 char s[50];
 printf("Enter a string: ");
 gets(s);
 printf("The string you entered: ");
 puts(s);
 }
```

## 1.5 getche()和getch()

getche():该函数会由键盘输入一个字符，返回给调用者，并在屏幕上显示读入的字符。由于它并不读取缓冲区的字符，只要用户输入字符，**getche()函数会立刻读取，而不需等待按【Enter】键**。通常用于程序中只需用户输入一个字符，即可往下继续执行的情形。

getch():它与getche()的区别是，**getch()不需将所输入的字符显示到屏幕上**。
